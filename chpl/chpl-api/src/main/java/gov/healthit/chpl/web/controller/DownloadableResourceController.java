package gov.healthit.chpl.web.controller;

import java.io.File;
import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang3.BooleanUtils;
import org.apache.commons.lang3.StringUtils;
import org.ff4j.FF4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import gov.healthit.chpl.FeatureList;
import gov.healthit.chpl.compliance.surveillance.SurveillanceManager;
import gov.healthit.chpl.domain.concept.CertificationEditionConcept;
import gov.healthit.chpl.exception.EntityRetrievalException;
import gov.healthit.chpl.exception.InvalidArgumentsException;
import gov.healthit.chpl.svap.manager.SvapManager;
import gov.healthit.chpl.util.ErrorMessageUtil;
import gov.healthit.chpl.util.FileUtils;
import gov.healthit.chpl.util.SwaggerSecurityRequirement;
import gov.healthit.chpl.web.controller.annotation.DeprecatedApi;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.log4j.Log4j2;

@Tag(name = "downloadable-resources", description = "Provides access to files generated by CHPL.")
@RestController
@Log4j2
public class DownloadableResourceController {
    private Environment env;
    private ErrorMessageUtil msgUtil;
    private SurveillanceManager survManager;
    private SvapManager svapManager;
    private FileUtils fileUtils;
    private FF4j ff4j;

    @Value("${directReviewsReportName}")
    private String directReviewsReportName;

    @Value("${schemaDirectReviewsName}")
    private String directReviewsSchemaName;

    @Autowired
    public DownloadableResourceController(Environment env,
            ErrorMessageUtil msgUtil,
            SurveillanceManager survManager,
            SvapManager svapManager,
            FileUtils fileUtils,
            FF4j ff4j) {
        this.env = env;
        this.msgUtil = msgUtil;
        this.survManager = survManager;
        this.svapManager = svapManager;
        this.fileUtils = fileUtils;
        this.ff4j = ff4j;
    }

    @Operation(summary = "Download all listings from the given edition in the specified format.",
            description = "Valid values for 'year' are 2011 and 2014. Listings from 2015 edition and "
                    + "beyond can be found in either the Active or Inactive files available for download "
                    + "at '/download/status/{status}.' Valid values for 'format' are csv, xml, and json.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY)
            })
    @RequestMapping(value = "/download/edition/{year}", method = RequestMethod.GET, produces = "application/xml")
    public void downloadListingsFromEdition(@PathVariable(value = "year", required = true) String editionInput,
            @RequestParam(value = "format", defaultValue = "xml", required = false) String formatInput,
            @RequestParam(value = "definition", defaultValue = "false", required = false) Boolean isDefinition,
            HttpServletRequest request, HttpServletResponse response) throws IOException, InvalidArgumentsException {
        String edition = normalizeEdition(editionInput);
        if (!edition.equals(CertificationEditionConcept.CERTIFICATION_EDITION_2011.getYear())
                && !edition.equals(CertificationEditionConcept.CERTIFICATION_EDITION_2014.getYear())) {
            throw new InvalidArgumentsException("Edition must be 2011 or 2014.");
        }
        String format = normalizeFormat(formatInput);
        if (!format.equals("xml") && !format.equals("csv") && !format.equals("json")) {
            throw new InvalidArgumentsException("Format must be XML, CSV, or JSON");
        }
        String responseType = getResponseType(format);

        File toDownload = null;
        if (BooleanUtils.isTrue(isDefinition)) {
            toDownload = getDefinitionDownloadFile(edition, format);
            if (!toDownload.exists()) {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.schemaFileNotFound", toDownload.getAbsolutePath()));
                return;
            }
        } else {
            File newestFileWithFormat = fileUtils.getNewestFileMatchingName("^chpl-" + edition + "-.+\\." + format + "$");
            if (newestFileWithFormat != null) {
                toDownload = newestFileWithFormat;
            } else {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.fileWithEditionAndFormatNotFound", edition, format));
                return;
            }
        }

        LOGGER.info("Downloading " + toDownload.getName());
        fileUtils.streamFileAsResponse(toDownload, responseType, response);
    }

    @Operation(summary = "Download all active or inactive listings in the CHPL.",
            description = "Valid values for 'status' are active and inactive. "
                    + "Valid values for 'format' are csv, xml, and json.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY)
            })
    @RequestMapping(value = "/download/{status:active|inactive}", method = RequestMethod.GET, produces = "application/xml")
    public void downloadListingsByStatus(@PathVariable(value = "status", required = true) String status,
            @RequestParam(value = "format", defaultValue = "xml", required = false) String formatInput,
            @RequestParam(value = "definition", defaultValue = "false", required = false) Boolean isDefinition,
            HttpServletRequest request, HttpServletResponse response) throws IOException, InvalidArgumentsException {
        String format = normalizeFormat(formatInput);
        if (!format.equals("xml") && !format.equals("csv") && !format.equals("json")) {
            throw new InvalidArgumentsException("Format must be XML, CSV, or JSON");
        }
        String responseType = getResponseType(format);

        File toDownload = null;
        if (BooleanUtils.isTrue(isDefinition)) {
            toDownload = getDefinitionDownloadFile(null, format);
            if (!toDownload.exists()) {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.schemaFileNotFound", toDownload.getAbsolutePath()));
                return;
            }
        } else {
            File newestFileWithFormat = fileUtils.getNewestFileMatchingName("^chpl-" + status + "-.+\\." + format + "$");
            if (newestFileWithFormat != null) {
                toDownload = newestFileWithFormat;
            } else {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.fileWithEditionAndFormatNotFound", status, format));
                return;
            }
        }

        LOGGER.info("Downloading " + toDownload.getName());
        fileUtils.streamFileAsResponse(toDownload, responseType, response);
    }

    private String normalizeEdition(String editionInput) {
        String edition = editionInput;
        if (!StringUtils.isEmpty(edition)) {
            // make sure it's a 4 character year
            edition = edition.trim();
            if (!edition.startsWith("20")) {
                edition = "20" + edition;
            }
        }
        return edition;
    }

    private String normalizeFormat(String formatInput) {
        String format = formatInput;
        if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("csv")) {
            format = "csv";
        } else if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("xml")) {
            format = "xml";
        } else {
            format = "json";
        }
        return format;
    }

    private String getResponseType(String format) {
        String responseType = "text/plain";
        if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("csv")) {
            responseType = "text/csv";
        } else if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("xml")) {
            responseType = "application/xml";
        } else {
            responseType = "application/json";
        }
        return responseType;
    }

    private File getDefinitionDownloadFile(String edition, String format) throws IOException {
        File toDownload = null;
        if (format.equals("xml")) {
            toDownload = fileUtils.getDownloadFile(env.getProperty("schemaXmlName"));
        } else if (!StringUtils.isEmpty(edition) && edition.equals("2011")) {
            toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsv2011Name"));
        } else if (!StringUtils.isEmpty(edition) && edition.equals("2014")) {
            toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsv2014Name"));
        } else {
            toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsvListingName"));
        }
        return toDownload;
    }

    @Deprecated
    @DeprecatedApi(friendlyUrl = "/download", removalDate = "2024-01-01",
        message = "The endpoint is deprecated and will be removed. Please GET from /download/edition/{year} "
                + "or /download/status/{status}.")
    @Operation(summary = "Download the entire CHPL in the specified format.",
            description = "Once per day, the entire certified product listing is "
                    + "written out to JSON and CSV files on the CHPL servers. There are files for the retired "
                    + "2011 and 2014 certification editions, as well as a file with Inactive listings and "
                    + "a file with Active listings. This method allows any user to download "
                    + "one of those files. The CSV file is formatted in such a way that users may import "
                    + "it into Microsoft Excel. The JSON file may be imported into any JSON tool of their choosing."
                    + "To download any one of the files, append ‘&edition=year’ to the end of the query string "
                    + "(e.g., &edition=2014). A separate query is required to download each file.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY)
            })
    @RequestMapping(value = "/download", method = RequestMethod.GET, produces = "application/xml")
    public void downloadListingDetails(@RequestParam(value = "edition", required = false) String editionInput,
            @RequestParam(value = "format", defaultValue = "xml", required = false) String formatInput,
            @RequestParam(value = "definition", defaultValue = "false", required = false) Boolean isDefinition,
            HttpServletRequest request, HttpServletResponse response) throws IOException {
        // parse inputs
        String edition = editionInput;
        String format = formatInput;
        String responseType = "text/csv";

        if (!StringUtils.isEmpty(edition)) {
            // make sure it's a 4 character year
            edition = edition.trim();
            if (!edition.startsWith("20")) {
                edition = "20" + edition;
            }
        } else {
            edition = "all";
        }

        if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("csv")) {
            format = "csv";
        } else if (!StringUtils.isEmpty(format) && format.equalsIgnoreCase("xml")) {
            format = "xml";
            responseType = "application/xml";
        } else {
            format = "json";
            responseType = "application/json";
        }

        File toDownload = null;
        // if the user wants a definition file, find it
        if (isDefinition != null && isDefinition.booleanValue()) {
            if (format.equals("xml")) {
                toDownload = fileUtils.getDownloadFile(env.getProperty("schemaXmlName"));
            } else if (edition.equals("2014")) {
                toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsv2014Name"));
            } else if (edition.equals("2015")) {
                if (ff4j.check(FeatureList.ERD_PHASE_3)) {
                    toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsv2015Name.postErdPhase3"));
                } else {
                    toDownload = fileUtils.getDownloadFile(env.getProperty("schemaCsv2015Name"));
                }
            }

            if (!toDownload.exists()) {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.schemaFileNotFound", toDownload.getAbsolutePath()));
                return;
            }
        } else {
            File newestFileWithFormat = fileUtils.getNewestFileMatchingName("^chpl-" + edition + "-.+\\." + format + "$");
            if (newestFileWithFormat != null) {
                toDownload = newestFileWithFormat;
            } else {
                response.getWriter()
                        .write(msgUtil.getMessage("resources.fileWithEditionAndFormatNotFound", edition, format));
                return;
            }
        }

        LOGGER.info("Downloading " + toDownload.getName());
        fileUtils.streamFileAsResponse(toDownload, responseType, response);
    }

    @Operation(summary = "Download a summary of SVAP activity as a CSV.",
            description = "Once per day, a summary of SVAP activity is written out to a CSV "
                    + "file on the CHPL servers. This method allows any user to download that file.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY),
                    @SecurityRequirement(name = SwaggerSecurityRequirement.BEARER)
            })
    @RequestMapping(value = "/svap/download", method = RequestMethod.GET, produces = "text/csv")
    public void downloadSvapSummary(
            @RequestParam(value = "definition", defaultValue = "false", required = false) Boolean isDefinition,
            HttpServletRequest request, HttpServletResponse response) throws IOException {
        File downloadFile = null;
        if (isDefinition != null && isDefinition.booleanValue()) {
            try {
                downloadFile = svapManager.getSvapSummaryDefinitionFile();
            } catch (IOException ex) {
                response.getWriter().append(ex.getMessage());
                return;
            }
        } else {
            try {
                downloadFile = svapManager.getSvapSummaryFile();
            } catch (IOException ex) {
                response.getWriter().append(ex.getMessage());
                return;
            }
        }

        if (downloadFile == null) {
            response.getWriter().append(msgUtil.getMessage("resources.schemaFileGeneralError"));
            return;
        }
        if (!downloadFile.exists()) {
            response.getWriter().append(msgUtil.getMessage("resources.schemaFileNotFound", downloadFile.getAbsolutePath()));
            return;
        }

        LOGGER.info("Streaming " + downloadFile.getName());
        fileUtils.streamFileAsResponse(downloadFile, "text/csv", response);
    }

    @Operation(summary = "Download all SED details for Listings that are certified to 170.315(g)(3).",
            description = "Download a specific file that is generated overnight.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY)
            })
    @RequestMapping(value = "/certified_products/sed_details", method = RequestMethod.GET)
    public void streamSEDDetailsDocumentContents(HttpServletResponse response)
            throws EntityRetrievalException, IOException {
        File downloadFile = fileUtils.getNewestFileMatchingName("^" + env.getProperty("SEDDownloadName") + "-.+\\.csv$");
        fileUtils.streamFileAsResponse(downloadFile, "text/csv", response);
    }

    @Operation(summary = "Download all direct reviews as a CSV.",
            description = "Once per day, all direct reviews are written out to a CSV "
                    + "file on the CHPL servers. This method allows any user to download that file.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY)
            })
    @RequestMapping(value = "/developers/direct-reviews/download", method = RequestMethod.GET, produces = "text/csv")
    public void downloadDirectReviews(
            @RequestParam(value = "definition", defaultValue = "false", required = false) Boolean isDefinition,
            HttpServletRequest request, HttpServletResponse response) throws IOException {
        File downloadFile = null;
        if (isDefinition != null && isDefinition.booleanValue()) {
            try {
                downloadFile = fileUtils.getDownloadFile(directReviewsSchemaName);
            } catch (IOException ex) {
                response.getWriter().append(ex.getMessage());
                return;
            }
        } else {
            try {
                downloadFile = fileUtils.getNewestFileMatchingName("^" + directReviewsReportName + "-.+\\.csv$");
            } catch (IOException ex) {
                response.getWriter().append(ex.getMessage());
                return;
            }
        }

        if (downloadFile == null) {
            response.getWriter().append(msgUtil.getMessage("resources.schemaFileGeneralError"));
            return;
        }
        if (!downloadFile.exists()) {
            response.getWriter().append(msgUtil.getMessage("resources.schemaFileNotFound", downloadFile.getAbsolutePath()));
            return;
        }

        LOGGER.info("Streaming " + downloadFile.getName());
        fileUtils.streamFileAsResponse(downloadFile, "text/csv", response);
    }

    @Operation(summary = "Download surveillance as CSV.",
            description = "Once per day, all surveillance and nonconformities are written out to CSV "
                    + "files on the CHPL servers. This method allows any user to download those files.",
            security = {
                    @SecurityRequirement(name = SwaggerSecurityRequirement.API_KEY),
                    @SecurityRequirement(name = SwaggerSecurityRequirement.BEARER)
            })
    @RequestMapping(value = "/surveillance/download", method = RequestMethod.GET, produces = "text/csv")
    public void downloadSurveillance(@RequestParam(value = "type", required = false, defaultValue = "") final String type,
            @RequestParam(value = "definition", defaultValue = "false", required = false) final Boolean isDefinition,
            final HttpServletRequest request, final HttpServletResponse response)
            throws IOException, EntityRetrievalException {

        File downloadFile = null;
        if (isDefinition != null && isDefinition.booleanValue()) {
            if (type.equalsIgnoreCase("basic")) {
                downloadFile = survManager.getBasicReportDownloadDefinitionFile();
            } else {
                downloadFile = fileUtils.getDownloadFile(env.getProperty("schemaSurveillanceName"));
            }
        } else {
            try {
                if (type.equalsIgnoreCase("all")) {
                    downloadFile = survManager.getAllSurveillanceDownloadFile();
                } else if (type.equalsIgnoreCase("basic")) {
                    downloadFile = survManager.getBasicReportDownloadFile();
                } else {
                    downloadFile = survManager.getSurveillanceWithNonconformitiesDownloadFile();
                }
            } catch (final IOException ex) {
                response.getWriter().append(ex.getMessage());
                return;
            }
        }

        if (downloadFile == null) {
            response.getWriter()
                    .append(msgUtil.getMessage("resources.schemaFileGeneralError"));
            return;
        }
        if (!downloadFile.exists()) {
            response.getWriter()
                    .write(msgUtil.getMessage("resources.schemaFileNotFound", downloadFile.getAbsolutePath()));
            return;
        }

        LOGGER.info("Downloading " + downloadFile.getName());
        fileUtils.streamFileAsResponse(downloadFile, "text/csv", response);
    }
}
